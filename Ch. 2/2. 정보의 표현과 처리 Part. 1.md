
```
연습문제 2.1 문제 
- 보기 좋게 살짝 수정했습니다.
A. 0x25B9D2에서 이진수로
B. 이진수 1010 1110 0100 1001에서 16진수로
C. 0xA8B3D에서 이진수로
D. 이진수 1100 1000 1011 0110 0101 10에서 16진수로
```
``` 
연습문제 2.1 해설
- A = 10, B = 11, C = 12, D = 13, E = 14, F = 15
A. 0010 0101 1011 1001 1101 0010

B. 0xBE49

C. 1010 1000 1011 0011 1101

D. 0x322D96
- 현재 비트 자리수의 합이 4의 배수가 아니므로, 앞에 0을 추가해 4의 배수로 만들어주어야 합니다.
- 예시로 십진법으로 나타낸 숫자 9의 경우 앞에다가 9을 추가해도 09로 같은 수가 되므로,
- 앞에다 0을 무한 번을 추가해도 값은 똑같이 유지가 됩니다.
- 위의 설명을 기반으로 수를 변환하자면 0011 0010 0010 1101 1001 0110으로 바뀌게 됩니다.
```

```
연습문제 2.2 문제
2의 n제곱 수가 주어졌을 때, 이를 각각 n, 10진수, 16진수에 대응되는 숫자를 채워 넣으시오.
n    10진수    16진수
5    32       0x20
23   __       __
__   32,768   __
__   __       0x2000
12   __       __
__   64       __
__   __       0x100
```
```
연습문제 2.2 해설
n    10진수    16진수
5    32       0x20
23   __       __    -> 8,388,608 | 0x800000
- 16진수의 자릿수의 배수를 생각해봅시다, 최하위 숫자는 16의 0제곱부터 시작해서
- 16의 1제곱, 16의 2제곱으로 올라가게 되므로
- 위의 규칙을 생각하면 쉽게 풀 수 있습니다.
__   32,768   __    -> 15    | 0x8000
__   __       0x2000-> 13    | 8,192
12   __       __    -> 4,096 | 0x1000
__   64       __    -> 6     | 0x40
__   __       0x100 -> 8     | 256
```

``` 
연습문제 2.3 문제
다음 표에 알맞은 수를 채우시오.
10진수      2진수       16진수
0          0000 0000  0x00
158        __         __
76         __         __
145        __         __
__         1010 1110  __
__         0011 1100  __
__         1111 0001  __
__         __         0x75
__         __         0xBD
__         __         0xF5
```
```
연습문제 2.3 해설
10진수      2진수       16진수
0          0000 0000  0x00
158        __         __       -> 1001 1110 | 0x9E
- 10진수를 2진수로 표현하는 것보다,
- 16진수로 표현하는 것이 더 간편하므로
- 16진수로 변환 후, 2진수로 변환하는 것이
- 조금이나마 더 간편합니다.
76         __         __       -> 0100 1100 | 0x4C
145        __         __       -> 1001 0001 | 0x91
__         1010 1110  __       -> 174       | 0xAE
- 위와 비슷한 논리로, 16진수로 변환 한 다음에
- 10진수로 변환하는 것이 편해보입니다.
__         0011 1100  __       -> 60        | 0x3C
__         1111 0001  __       -> 241       | 0xF1
__         __         0x75     -> 117       | 0111 0101
__         __         0xBD     -> 189       | 1011 1101
__         __         0xF5     -> 245       | 1111 0101
```

```
연습문제 2.4 문제
모든 수를 16진수로 표현하고, 그 형태를 유지한 채로 계산하시오.
A. 0x605c + 0x5    = ______
B. 0x605c - 0x20   = ______
C. 0x605c + 32     = ______
D. 0x60fa - 0x605c = ______
```
```
연습문제 2.4 해설
- 일단 모든 수를 동일한 자릿수로 표현하겠습니다.
A. 0x605c + 0x0005 = ______ -> 0x6061
- 10진수 계산과 동일하게 16이 초과되면 다음으로 넘겨 계산하면 됩니다.
B. 0x605c - 0x0020 = ______ -> 0x603c
C. 0x605c + 0x0020 = ______ -> 0x607c
D. 0x60fa - 0x605c = ______ -> 0xc156
```

- word size는 cpu가 한 번에 처리할 수 있는 크기의 단위를 의미하며 과거에는 32비트, 최근에는 64비트가 보편적으로 사용됩니다.
- 위의 크기에 따라서 포인터의 크기가 32비트 또는 64비트로 결정됩니다.
- 포인터의 크기가 중요한 이유는, 접근할 수 있는 메모리의 범위를 결정하기 때문입니다.
- 32비트 포인터라면 약 4기가바이트 범위의 메모리만 접근이 가능해져서, 최근 컴퓨터 사양에 비해
- 다소 적은 감이 있습니다.
- 64비트 컴퓨터는 32비트 컴퓨터로 변환이 가능하지만, 역은 성립하지 않습니다.
- 참고로 32비트, 64비트 컴퓨터에 따라 동일한 데이터 타입이어도, 크기가 달라집니다.

##### 데이터 저장
1.  0x100 주소에 4바이트 정수를 저장한다고 가정해봅시다.
2. 일반적으로 0x100, 0x101, 0x102, 0x103으로 연속된 주소가 할당되어 각각의 위치에 값들이 저장될 것입니다.
3. most significant bit(가장 중요한 비트)라는 개념이 있는데, 이는 데이터에 가장 앞에 오는 비트를 의미합니다. 
- 예를 들어, 1000 0000 이라는 1바이트 데이터가 있으면, 1이 most significant bit가 됩니다.

- 컴퓨터 타입에 따라 Big endian, Little endian 방식으로 데이터를 저장하게 됩니다.
- 4바이트 정수가 0x01234567이라고 가정한다면, 각각의 방식은 아래와 같이 데이터를 저장하게 됩니다.

|               | 0x100 | 0x101 | 0x102 | 0x103 |
| ------------- | ----- | ----- | ----- | ----- |
| Big endian    | 01    | 23    | 45    | 67    |
| Little endian | 67    | 45    | 23    | 01    |
- 사실 위의 규칙은 개발할 때에 웬만하면 우리가 모르고 지나쳐도 되는 것들입니다.
- 하지만 규칙이 다른 컴퓨터로 데이터를 전송할 때는 이야기가 달라집니다. 이에 따른 관습을 지켜야 하는데, 이는 11장에서 배운다고 합니다.
- 또 다른 하나의 문제는 우리가 low level의 코드를 분석할 때, 위의 규칙을 모른다면 오해하는 상황이 발생합니다.

``` C++
// 연습 문제 2-5 코드
#include <stdio.h>  
  
typedef unsigned char* byte_pointer;  
  
void show_bytes(byte_pointer start, size_t len) {  
    for (size_t i = 0; i < len; i++) {  
       printf("%.2x", start[i]);  
    }  
    printf("\n");  
}  
  
int main () {  
    int a = 0x12345678;  
    show_bytes((byte_pointer)&a, 1);  // A
    show_bytes((byte_pointer)&a, 2);  // B
    show_bytes((byte_pointer)&a, 3);  // C
  
    return 0;  
}
```
```
연습문제 2-5 문제
위의 코드를 실행시켰을 때, 각각의 출력 결과를 나타내시오.
A. 리틀 :        빅 :
B. 리틀 :        빅 :
C. 리틀 :        빅 :
```
```
연습문제 2-5 해설
- 주소의 시작은 0x100이라고 가정하겠습니다.
|               | 0x100 | 0x101 | 0x102 | 0x103 |
| ------------- | ----- | ----- | ----- | ----- |
| Big endian    | 12    | 34    | 56    | 78    |
| Little endian | 78    | 56    | 34    | 12    |
- 위에서 적은 표를 참고해 작성했습니다. 답안 작성은 1바이트, 2바이트, 3바이트로 증가하므로 맞춰서 작성하면 아래와 같습니다.
A. 리틀 : 78     빅 : 12
B. 리틀 : 7856   빅 : 1234
C. 리틀 : 785634 빅 : 123456
```

```
연습문제 2-6 문제
정수 2607352가 16진수 표시 0x0027C8F8를 가지며, 부동소수점 수 3510593.0이 16진수 표시 0x4A1F23E0를 갖는다.
A. 이 두개의 16진수 값을 이진수로 표시하라.
B. 이 두 개의 스트링을 하나를 기준으로 일치하는 비트의 수가 최대가 될 때까지 다른 하나를 쉬프트하라. 몇 개의 비트가 일치하는가?
C. 스트링의 어떤 부분이 일치하지 않는가?
```
```
연습문제 2-6 해설
A. 0x0027C8F8 : 0000 0000 0010 0111 1100 1000 1111 1000
A. 0x4A1F23E0 : 0100 1010 0001 1111 0010 0011 1110 0000
- 0100 1010 0001 1111 0010 0011 1110 0000를 '>>' 연산 두 번을 실행하면 아래와 같습니다.
- 0001 0010 1000 0111 1100 1000 1111 1000
- 0000 0000 0010 0111 1100 1000 1111 1000
B. 21비트
C. 3번, 6번, 8번, 10번
```

```
연습문제 2-7 문제
다음과 같이 show_bytes을 호출하면 무엇이 출력되는가?
- show_bytes 함수는 2-5 코드를 참고합시다.
const char* m = "mnopqr";
show_bytes((byte_pointer) m, strlen(m));

```
```
연습문제 2-7 해설
- 주소값을 출력하는 게 아니므로, 리틀 엔디안, 빅 엔디안 상관없이 같은 값이 출력됩니다.
6d6e6f707172
```